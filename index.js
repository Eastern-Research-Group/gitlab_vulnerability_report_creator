import { readFileSync, writeFileSync } from "node:fs";
import path, { resolve } from "node:path";
import { fileURLToPath } from "url";

import "./types.js";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Format a timestamp to a human-readable date.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatDate(timestamp = null, long = true) {
  const date = new Date(timestamp ?? Date.now());
  /** @type Intl.DateTimeFormatOptions */
  const options = {
    day: "numeric",
    month: "long",
    weekday: "long",
    year: "numeric",
  };
  return date.toLocaleDateString("en-US", long ? options : undefined);
}

/**
 * Format a timestamp to a human-readable datetime.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatTime(timestamp = null) {
  const date = new Date(timestamp ?? Date.now());
  return date.toLocaleString("en-US");
}

/**
 * Generate HTML for a list of scanned endpoints.
 * @param {Endpoint[]} endpoints - The list of scanned endpoints
 */
function generateEndpointsHtml(endpoints) {
  return endpoints
    .map(
      (endpoint) => `
    <tr>
      <td>${endpoint.url}</td>
      <td>${endpoint.scannerId}</td>
    <tr>
  `,
    )
    .join("");
}

/**
 * Generate separate sections with expanded details for each vulnerability.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 */
function generateExpandedResultsHtml(vulnerabilities) {
  /** @type VulnerabilityMap */
  const vulnerabilityMap = vulnerabilities.reduce((acc, vuln) => {
    const name = getVulnerabilityCommonName(vuln);
    return {
      ...acc,
      [name]: {
        id: vuln.id,
        instances: (acc[name]?.instances ?? []).concat(vuln.evidence),
      },
    };
  }, {});
  return Object.entries(vulnerabilityMap)
    .map(
      ([name, data]) => `
    <div class="mb-4" id=${data.id}>
      <h3>${name}</h3>
      <table>
        <thead>
          <tr>
            <th>Request</th>
            <th>Response</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
        ${data.instances
          .map(
            (inst) => `
          <tr>
            ${
              inst.request
                ? `<td>${inst.request.method} ${inst.request.url}</td>`
                : "<td>None</td>"
            }
            ${
              inst.response
                ? `<td>${inst.response.status_code} ${inst.response.reason_phrase}: ${inst.response.body}</td>`
                : "<td>None</td>"
            }
            <td>${inst.summary}</td>
          </tr>
        `,
          )
          .join("")}
        </tbody>
      </table>
    </div>
  `,
    )
    .join("");
}

/**
 * Generate HTML page from parsed data.
 * @param {string[]} filePaths - The list of JSON file paths
 * @returns {string}
 */
function generateHtmlPage(filePaths) {
  const data = filePaths.map((filePath) => readJSONFile(filePath));
  const parsedData = parseData(data);

  const templateMap = {
    endpoints: generateEndpointsHtml(parsedData.endpoints),
    kpis: generateKpiHtml(parsedData.kpis),
    reportDate: formatDate(),
    results: generateResultsHtml(parsedData.vulnerabilities),
    resultSections: generateExpandedResultsHtml(parsedData.vulnerabilities),
    scanners: generateScanMetadataHtml(parsedData.scans),
  };

  const htmlTemplate = readFileSync(
    resolve(__dirname, "template.html"),
    "utf8",
  );
  const htmlContent = htmlTemplate.replace(/({{\w+}})/g, (_match, p1) => {
    const key = p1.slice(2, -2);
    return templateMap[key];
  });
  return htmlContent;
}

/**
 * Generate HTML for severity counts.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @returns {string}
 */
function generateKpiHtml(kpis) {
  return Object.entries(kpis)
    .map(
      ([severity, count]) => `
    <div class="mt-2.5">
      <div class="text-center border border-solid border-gray-300 bg-gray-100 rounded-t-lg font-medium h-12 flex justify-center items-center">
          ${severity}
      </div>
      <div class="text-center border border-solid border-gray-300 rounded-b-lg font-medium h-20 flex justify-center items-center text-3xl border-t-0">
         ${count} 
      </div>
  </div>
`,
    )
    .join("");
}

/**
 * Select the most relevant identifier for a vulnerability.
 * @param {Vulnerability} vuln - The vulnerability to select an identifier for
 * @returns {string}
 */
function getVulnerabilityCommonName(vuln) {
  return vuln.identifiers.reduce((current, id) => {
    if (["browserker", "ApiSecurityCheck"].includes(id.type.toLowerCase())) {
      return id.name;
    } else if (!current) {
      return id.name;
    }
    return id.name;
  }, "");
}

/**
 * Generate HTML for vulnerability results.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 * @returns {string}
 */
function generateResultsHtml(vulnerabilities) {
  return vulnerabilities
    .map(
      (vuln) => `
      <tr>
        <td class="p-2">${formatDate(vuln.discovered_at, false)}</td>
        <td class="p-2">${vuln.severity}</td>
        <td class="p-2 w-6/12">${vuln.description ?? "None"}</td>
        <td class="p-2">
          <a href="#${vuln.id}">${getVulnerabilityCommonName(vuln)}</a>
        </td>
    `,
    )
    .join("");
}

/**
 * Generate HTML for a scanner's metadata.
 * @param {ScanMetadata[]} scans - The metadata of the scan result data
 * @returns {string}
 */
function generateScanMetadataHtml(scans) {
  return scans
    .map(
      (scan) => `
    <tr>
      <td>${formatTime(scan.start_time)} - ${formatTime(scan.end_time)}</td>
      <td><a href="${scan.url}" target="_blank" rel="noopener noreferrer">${
        scan.name
      }</a></td>
      <td>${scan.version}</td>
      <td>${scan.id}</td>
    </tr>
  `,
    )
    .join("");
}

/**
 * Parse data from JSON scan files.
 * @param {DastResultData[]} data - An array of scan result data
 * @returns {ParsedData}
 */
function parseData(data) {
  /** @type {ParsedData} */
  const accumulator = {
    endpoints: [],
    kpis: {},
    scans: [],
    vulnerabilities: [],
  };
  return data.reduce((sections, datum) => {
    return {
      ...sections,
      endpoints: sections.endpoints.concat(
        datum.scan.scanned_resources.map((resource) => ({
          url: resource.url,
          scannerId: datum.scan.scanner.id,
        })),
      ),
      kpis: updateKpis(sections.kpis, datum.vulnerabilities),
      scans: sections.scans.concat({
        ...datum.scan.scanner,
        start_time: datum.scan.start_time,
        end_time: datum.scan.end_time,
      }),
      vulnerabilities: sections.vulnerabilities.concat(datum.vulnerabilities),
    };
  }, accumulator);
}

/**
 * Read a JSON file.
 * @param {string} filePath - A JSON file to parse
 * @returns {DastResultData}
 */
function readJSONFile(filePath) {
  try {
    const jsonData = readFileSync(filePath, "utf8");
    return JSON.parse(jsonData);
  } catch (err) {
    console.error("Error reading JSON file:", err);
    throw err;
  }
}

/**
 * Generate an object enumerating the counts of each severity level discovered in the scan.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @param {Vulnerability[]} vulns - The list of discovered vulnerabilities
 * @return {{ [key: string]: number }}
 */
function updateKpis(kpis, vulns) {
  return vulns.reduce((kpis, vuln) => {
    const severity = vuln.severity;
    kpis[severity] = kpis[severity] + 1 || 1;
    return kpis;
  }, kpis);
}

/*
## Main
*/

// Read filenames from command-line arguments (excluding the first two elements which are node and script path).
const filePaths = process.argv.slice(2);

// Check if filenames are provided.
if (filePaths.length === 0) {
  console.error("Please provide at least one JSON file path.");
  process.exit(1);
}

// Generate an HTML page from the provided JSON files.
const htmlContent = generateHtmlPage(filePaths);
const filepath = resolve(__dirname, "output", "report.html");
writeFileSync(filepath, htmlContent);
console.log(`Vulnerability report written to ${filepath}.`);
