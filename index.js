import { readFileSync, writeFileSync } from "node:fs";
import path, { resolve } from "node:path";
import { parseArgs } from "node:util";
import { fileURLToPath } from "url";

import "./types.js";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const linkStyles = "underline text-blue-600";

/**
 * Escape the HTML tags in a string.
 * @param {string} input - The string to escape
 * @returns {string}
 */
function escapeHtmlTags(input = "") {
  return input.replace(/[<>&"'']/g, function (match) {
    return {
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
    }[match];
  });
}
/**
 * Format a timestamp to a human-readable date.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatDate(timestamp = null, long = true) {
  const date = new Date(timestamp ?? Date.now());
  /** @type Intl.DateTimeFormatOptions */
  const options = {
    day: "numeric",
    month: "long",
    weekday: "long",
    year: "numeric",
  };
  return date.toLocaleDateString("en-US", long ? options : undefined);
}

/**
 * Format a timestamp to a human-readable datetime.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatTime(timestamp = null) {
  const date = new Date(timestamp ?? Date.now());
  return date.toLocaleString("en-US");
}

/**
 * Generate HTML for a list of scanned endpoints.
 * @param {Endpoint[]} endpoints - The list of scanned endpoints
 */
function generateEndpointsHtml(endpoints) {
  return endpoints
    .map(
      (endpoint) => `
    <tr>
      <td class="p-2 break-words">${endpoint.url}</td>
      <td class="p-2">${endpoint.scannerId}</td>
    <tr>
  `,
    )
    .join("");
}

/**
 * Generate separate sections with expanded details for each vulnerability.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 */
function generateExpandedResultsHtml(vulnerabilities) {
  /** @type VulnerabilityMap */
  const vulnerabilityMap = vulnerabilities.reduce((acc, vuln) => {
    const name = getVulnerabilityCommonName(vuln);
    return {
      ...acc,
      [name]: {
        date: vuln.discovered_at,
        name: getVulnerabilityCommonName(vuln),
        instances: (acc[name]?.instances ?? []).concat(vuln.evidence),
      },
    };
  }, {});

  /** @param {ScanResponse | null} res */
  const responseCell = (res) => {
    if (!res) return "None";
    let row = `${res.status_code} ${res.reason_phrase}`;
    if (res.body) row += `: ${res.body}`;
    return row;
  };

  return Object.entries(vulnerabilityMap)
    .map(
      ([name, data]) => `
    <div class="mb-4" id=${data.name.replace(/ /g, "-")}>
      <h3 class="text-xl font-semibold">${name}</h3>
      <table class="table-fixed w-full">
        <thead class="font-semibold text-left border-b-2 border-solid border-gray-300">
          <tr>
            <th class="p-2">Detected</th>
            <th class="p-2">Request</th>
            <th class="p-2">Response</th>
            <th class="p-2">Description</th>
          </tr>
        </thead>
        <tbody>
        ${data.instances
          .map((inst) => {
            const { request, response, summary } = inst;
            return `
          <tr>
            <td class="p-2">${formatTime(data.date)}</td>
            <td class="p-2 break-words">${
              request ? `${request.method} ${request.url}` : "None"
            }</td>
            <td class="p-2">
              ${responseCell(response)}
            </td>
            <td class="p-2">${escapeHtmlTags(summary) ?? "None"}</td>
          </tr>
        `;
          })
          .join("")}
        </tbody>
      </table>
    </div>
  `,
    )
    .join("");
}

/**
 * Generate HTML page from parsed data.
 * @param {string[]} filePaths - The list of JSON file paths
 * @returns {string}
 */
function generateHtmlPage(filePaths) {
  const data = filePaths.map((filePath) => readJSONFile(filePath));
  const parsedData = parseData(data);

  const templateMap = {
    endpoints: generateEndpointsHtml(parsedData.endpoints),
    kpis: generateKpiHtml(parsedData.kpis),
    reportDate: formatDate(),
    results: generateResultsHtml(parsedData.vulnerabilities),
    resultSections: generateExpandedResultsHtml(parsedData.vulnerabilities),
    scanners: generateScanMetadataHtml(parsedData.scans),
  };

  const htmlTemplate = readFileSync(
    resolve(__dirname, "template.html"),
    "utf8",
  );
  const htmlContent = htmlTemplate.replace(/({{\w+}})/g, (_match, p1) => {
    const key = p1.slice(2, -2);
    return templateMap[key];
  });
  return htmlContent;
}

/**
 * Generate HTML for severity counts.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @returns {string}
 */
function generateKpiHtml(kpis) {
  return Object.entries(kpis)
    .map(
      ([severity, count]) => `
    <div class="mt-2.5">
      <div class="text-center border border-solid border-gray-300 bg-gray-100 rounded-t-lg font-medium h-12 flex justify-center items-center">
          ${severity}
      </div>
      <div class="text-center border border-solid border-gray-300 rounded-b-lg font-medium h-20 flex justify-center items-center text-3xl border-t-0">
         ${count} 
      </div>
  </div>
`,
    )
    .join("");
}

/**
 * Select the most relevant identifier for a vulnerability.
 * @param {Vulnerability} vuln - The vulnerability to select an identifier for
 * @returns {string}
 */
function getVulnerabilityCommonName(vuln) {
  return vuln.identifiers.reduce((current, id) => {
    if (["browserker", "ApiSecurityCheck"].includes(id.type.toLowerCase())) {
      return id.name;
    } else if (!current) {
      return id.name;
    }
    return id.name;
  }, "");
}

/**
 * Generate HTML for vulnerability results.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 * @returns {string}
 */
function generateResultsHtml(vulnerabilities) {
  let discovered = new Set();
  return vulnerabilities
    .map((vuln) => ({
      ...vuln,
      name: getVulnerabilityCommonName(vuln),
    }))
    .filter((vuln) => {
      if (!discovered.has(vuln.name)) {
        discovered.add(vuln.name);
        return true;
      }
      return false;
    })
    .map(
      (vuln) => `
      <tr>
        <td class="p-2">${vuln.severity}</td>
        <td class="p-2 w-6/12">${vuln.description ?? "None"}</td>
        <td class="p-2">
          <a class="${linkStyles}" href="#${vuln.name.replace(/ /g, "-")}">${
            vuln.name
          }</a>
        </td>
    `,
    )
    .join("");
}

/**
 * Generate HTML for a scanner's metadata.
 * @param {ScanMetadata[]} scans - The metadata of the scan result data
 * @returns {string}
 */
function generateScanMetadataHtml(scans) {
  return scans
    .map(
      (scan) => `
    <tr>
      <td class="p-2">${formatTime(scan.start_time)} - ${formatTime(
        scan.end_time,
      )}</td>
      <td class="p-2"><a class="${linkStyles}" href="${
        scan.url
      }" target="_blank" rel="noopener noreferrer">${scan.name}</a></td>
      <td class="p-2">${scan.version}</td>
      <td class="p-2">${scan.id}</td>
    </tr>
  `,
    )
    .join("");
}

/**
 * Parse data from JSON scan files.
 * @param {DastResultData[]} data - An array of scan result data
 * @returns {ParsedData}
 */
function parseData(data) {
  const severities = ["Low", "Medium", "High", "Critical", "Info", "Unknown"];
  /** @type {ParsedData} */
  const accumulator = {
    endpoints: [],
    kpis: severities.reduce((obj, sev) => ({ ...obj, [sev]: 0 }), {}),
    scans: [],
    vulnerabilities: [],
  };
  return data.reduce((sections, datum) => {
    return {
      ...sections,
      endpoints: sections.endpoints.concat(
        datum.scan.scanned_resources.map((resource) => ({
          url: resource.url,
          scannerId: datum.scan.scanner.id,
        })),
      ),
      kpis: updateKpis(sections.kpis, datum.vulnerabilities),
      scans: sections.scans.concat({
        ...datum.scan.scanner,
        start_time: datum.scan.start_time,
        end_time: datum.scan.end_time,
      }),
      vulnerabilities: sections.vulnerabilities.concat(datum.vulnerabilities),
    };
  }, accumulator);
}

/**
 * Read a JSON file.
 * @param {string} filePath - A JSON file to parse
 * @returns {DastResultData}
 */
function readJSONFile(filePath) {
  try {
    const jsonData = readFileSync(filePath, "utf8");
    return JSON.parse(jsonData);
  } catch (err) {
    console.error("Error reading JSON file:", err);
    throw err;
  }
}

/**
 * Generate an object enumerating the counts of each severity level discovered in the scan.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @param {Vulnerability[]} vulns - The list of discovered vulnerabilities
 * @return {{ [key: string]: number }}
 */
function updateKpis(kpis, vulns) {
  return vulns.reduce((kpis, vuln) => {
    const severity = vuln.severity;
    kpis[severity] = kpis[severity] + 1 || 1;
    return kpis;
  }, kpis);
}

/*
## Main
*/

// Read filenames from command-line arguments
const {
  values: { outFilePath },
  positionals: inFilePaths,
} = parseArgs({
  options: {
    outFilePath: {
      type: "string",
      short: "o",
    },
  },
  allowPositionals: true,
});

// Check if filenames are provided.
if (inFilePaths.length === 0) {
  console.error("Please provide at least one JSON file path.");
  process.exit(1);
}

// Generate an HTML page from the provided JSON files.
const htmlContent = generateHtmlPage(inFilePaths);
const filepath = resolve(__dirname, outFilePath ?? "output/report.html");
writeFileSync(filepath, htmlContent);
console.log(`Vulnerability report written to ${filepath}.`);
