import { readFileSync, writeFileSync } from "node:fs";
import path, { resolve } from "node:path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Format a timestamp to a human-readable date.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatDate(timestamp = null) {
  const date = new Date(timestamp ?? Date.now());
  return `${date.getMonth()} ${date.getDate()}, ${date.getFullYear()}`;
}

/**
 * Format a timestamp to a human-readable datetime.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatTime(timestamp) {
  const date = new Date(timestamp ?? Date.now());
  const hour = date.getHours();
  const period = hour < 12 ? "AM" : "PM";
  const periodHour = hour % 12 || 12;
  return `${periodHour}:${date.getMinutes()}:${date.getSeconds()} ${period}`;
}

/**
 * Generate HTML for a list of scanned endpoints.
 * @param {Endpoint[]} endpoints - The list of scanned endpoints
 */
function generateEndpointsHtml(endpoints) {
  return endpoints
    .map(
      (endpoint) => `
    <tr>
      <td>${endpoint.url}</td>
      <td>${endpoint.scannerId}</td>
    <tr>
  `,
    )
    .join("");
}

/**
 * Generate separate sections with expanded details for each vulnerability.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 */
function generateExpandedResultsHtml(vulnerabilities) {
  return vulnerabilities
    .map(
      (vuln) => `
    <div class="mb-4">
      <h3
    </div>
  `,
    )
    .join("");
}

/**
 * Generate HTML page from parsed data.
 * @param {string[]} filePaths - The list of JSON file paths
 * @returns {string}
 */
function generateHtmlPage(filePaths) {
  const htmlTemplate = readFileSync(
    resolve(__dirname, "template.html"),
    "utf8",
  );
  const reportDate = formatDate();
  const data = filePaths.map((filePath) => readJSONFile(filePath));
  const parsedData = parseData(data);
  const scanMetadataHtml = parsedData.scans.map(generateScanMetadataHtml);
  const kpiHtml = generateKpiHtml(parsedData.kpis);
  const resultsHtml = generateResultsHtml(parsedData.vulnerabilities);
  const endpointsHtml = generateEndpointsHtml(parsedData.endpoints);
  const expandedResultsHtml = generateExpandedResultsHtml(
    parsedData.vulnerabilities,
  );

  const htmlContent = "";
  return htmlContent;
}

/**
 * Generate HTML for severity counts.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @returns {string}
 */
function generateKpiHtml(kpis) {
  return Object.entries(kpis)
    .map(
      ([severity, count]) => `
    <div class="mt-2.5">
      <div class="text-center border border-solid border-gray-300 bg-gray-100 rounded-t-lg font-medium h-12 flex justify-center items-center">
          ${severity}
      </div>
      <div class="text-center border border-solid border-gray-300 rounded-b-lg font-medium h-20 flex justify-center items-center text-3xl border-t-0">
         ${count} 
      </div>
  </div>
`,
    )
    .join("");
}

/**
 * Select the most relevant identifier for a vulnerability.
 * @param {Vulnerability} vuln - The vulnerability to select an identifier for
 * @returns {string}
 */
function getVulnerabilityCommonName(vuln) {
  return vuln.identifiers.reduce((current, id) => {
    if (["browserker", "ApiSecurityCheck"].includes(id.type.toLowerCase())) {
      return id.name;
    } else if (!current) {
      return id.name;
    }
    return id.name;
  }, "");
}

/**
 * Generate HTML for vulnerability results.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 * @returns {string}
 */
function generateResultsHtml(vulnerabilities) {
  return vulnerabilities
    .map(
      (vuln) => `
      <tr>
        <td class="p-2">${formatDate(vuln.discovered_at)}</td>
        <td class="p-2">${vuln.severity}</td>
        <td class="p-2 w-6/12">${vuln.description ?? "None"}</td>
        <td class="p-2">
          <a href="${vuln.id}">${getVulnerabilityCommonName(vuln)}</a>
        </td>
    `,
    )
    .join("");
}

/**
 * Generate HTML for a scanner's metadata.
 * @param {ScanMetadata} scan - The metadata of the scan result data
 * @returns {string}
 */
function generateScanMetadataHtml(scan) {
  return `
    <tr>
      <td>${formatTime(scan.start_time)} - ${formatTime(scan.end_time)}</td>
      <td><a href="${scan.url}" target="_blank" rel="noopener noreferrer">${
        scan.name
      }</a></td>
      <td>${scan.version}</td>
      <td>${scan.id}</td>
    </tr>
  `;
}

/**
 * Parse data from JSON scan files.
 * @param {DastResultData[]} data - An array of scan result data
 * @returns {ParsedData}
 */
function parseData(data) {
  /** @type {ParsedData} */
  const accumulator = {
    endpoints: [],
    kpis: {},
    scans: [],
    vulnerabilities: [],
  };
  return data.reduce((sections, datum) => {
    return {
      ...sections,
      endpoints: sections.endpoints.concat(
        datum.scan.scanned_resources.map((resource) => ({
          url: resource.url,
          scannerId: datum.scan.scanner.id,
        })),
      ),
      kpis: updateKpis(sections.kpis, datum.vulnerabilities),
      scans: sections.scans.concat({
        ...datum.scan.scanner,
        start_time: datum.scan.start_time,
        end_time: datum.scan.end_time,
      }),
      vulnerabilities: sections.vulnerabilities.concat(datum.vulnerabilities),
    };
  }, accumulator);
}

/**
 * Read a JSON file.
 * @param {string} filePath - A JSON file to parse
 * @returns {DastResultData}
 */
function readJSONFile(filePath) {
  try {
    const jsonData = readFileSync(filePath, "utf8");
    return JSON.parse(jsonData);
  } catch (err) {
    console.error("Error reading JSON file:", err);
    throw err;
  }
}

/**
 * Generate an object enumerating the counts of each severity level discovered in the scan.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @param {Vulnerability[]} vulns - The list of discovered vulnerabilities
 * @return {{ [key: string]: number }}
 */
function updateKpis(kpis, vulns) {
  return vulns.reduce((kpis, vuln) => {
    const severity = vuln.severity;
    kpis[severity] = kpis[severity] + 1 || 1;
    return kpis;
  }, kpis);
}

/*
## Types
*/

/**
 * @typedef DastResultData
 * @type {object}
 * @property {Scan} scan - Scan result metadata
 * @property {Vulnerability[]} vulnerabilities - Descriptions of discovered Vulnerabilities
 */

/**
 * @typedef Endpoint
 * @property {string} url - URL of the endpoint
 * @property {string} scannerId - Scanner identifier
 */

/**
 * @typedef Identifier
 * @type {object}
 * @property {string} name - Common name for the vulnerability
 * @property {string} type - Type of identifier
 * @property {string} url - Link to a description of the vulnerability
 */

/**
 * @typedef Instance
 * @type {object}
 * @property {Request} request - Request metadata
 * @property {Response} response - Response metadata
 * @property {string} summary - Summary of the finding
 */

/**
 * @typedef ParsedData
 * @type {object}
 * @property {Endpoint[]} endpoints - List of scanned endpoints
 * @property {{ [key: string]: number }} kpis - Key performance indicators
 * @property {ScanMetadata[]} scans - List of scanners used
 * @property {Vulnerability[]} vulnerabilities - List of discovered vulnerabilities
 */

/**
 * @typedef Request
 * @type {object}
 * @property {string} method - HTTP method of the request
 * @property {Response} url - URL of the request
 */

/**
 * @typedef Response
 * @type {object}
 * @property {string} reason_phrase - Reason phrase for the response status code
 * @property {number} status_code - HTTP status code of the response
 * @property {string} body - Body of the response
 */

/**
 * @typedef Scan
 * @type {object}
 * @property {string} end_time - Time when the scan ended
 * @property {Array<{ url: string }>} scanned_resources - List of scanned endpoints
 * @property {Scanner} scanner - Scanner metadata
 * @property {string} start_time - Time when the scan started
 * @property {string} status - Status of the scan
 */

/**
 * @typedef {Scanner & { start_time: string, end_time: string }} ScanMetadata
 */

/**
 * @typedef Scanner
 * @type {object}
 * @property {string} id - Unique identifier for the scanner
 * @property {string} name - Common name for the scanner
 * @property {string} url - URL for the scanner's homepage
 * @property {string} version - Version of the scanner
 */

/**
 * @typedef Vulnerability
 * @type {object}
 * @property {string} description - Detailed description of the vulnerability
 * @property {string} discovered_at - Time during the scan when the vulnerability was discovered
 * @property {Instance[]} evidence - Specific instances of the vulnerability found during the scan
 * @property {string} id - Unique identifier for the vulnerability
 * @property {Identifier[]} identifiers - Common descriptions or CWE categories of the vulnerability
 * @property {string} severity - Severity level of the vulnerability
 */

/*
## Main
*/

// Read filenames from command-line arguments (excluding the first two elements which are node and script path).
const filePaths = process.argv.slice(2);

// Check if filenames are provided.
if (filePaths.length === 0) {
  console.error("Please provide at least one JSON file path.");
  process.exit(1);
}

// Generate an HTML page from the provided JSON files.
const htmlContent = generateHtmlPage(filePaths);
const filepath = resolve(__dirname, "output", "report.html");
writeFileSync(filepath, htmlContent);
console.log(`Vulnerability report written to ${filepath}.`);
