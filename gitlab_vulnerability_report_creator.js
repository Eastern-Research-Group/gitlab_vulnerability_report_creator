import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { basename, dirname, resolve } from "node:path";
import { exit } from "node:process";
import { parseArgs } from "node:util";
import { fileURLToPath } from "url";

import "./types.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const isInsideDocker = process.env.INSIDE_DOCKER === 'true';

/**
 * Escape the HTML tags in a string.
 * @param {string} input - The string to escape
 * @returns {string}
 */
function escapeHtmlTags(input = "") {
  return input.replace(/[<>&"'']/g, function (match) {
    return {
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
    }[match];
  });
}

/**
 * Format a timestamp to a human-readable date.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatDate(timestamp = null, long = true) {
  const date = new Date(timestamp ?? Date.now());
  /** @type Intl.DateTimeFormatOptions */
  const options = {
    day: "numeric",
    month: "long",
    weekday: "long",
    year: "numeric",
  };
  return date.toLocaleDateString("en-US", long ? options : undefined);
}

/**
 * Format a timestamp to a human-readable datetime.
 * @param {string | null} timestamp - A timestamp that can be parsed by the Date constructor
 * @returns {string}
 */
function formatTime(timestamp = null) {
  const date = new Date(timestamp ?? Date.now());
  return date.toLocaleString("en-US");
}

/**
 * Generate HTML for a list of scanned endpoints.
 * @param {Endpoint[]} endpoints - The list of scanned endpoints
 */
function generateEndpointsHtml(endpoints) {
  return endpoints
    .map(
      (endpoint) => `
    <tr>
      <td class="break-words">${endpoint.url}</td>
      <td>${endpoint.scannerId}</td>
    <tr>
  `,
    )
    .join("");
}

/**
 * Generate separate sections with expanded details for each vulnerability.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 */
function generateExpandedResultsHtml(vulnerabilities) {
  /** @type VulnerabilityMap */
  const vulnerabilityMap = vulnerabilities.reduce((acc, vuln) => {
    const name = getVulnerabilityCommonName(vuln);
    return {
      ...acc,
      [name]: {
        date: vuln.discovered_at ?? vuln.details?.discovered_at.value,
        name: getVulnerabilityCommonName(vuln),
        instances: (acc[name]?.instances ?? []).concat(vuln.evidence),
      },
    };
  }, {});

  /** @param {ScanResponse | null} res */
  const responseCell = (res) => {
    if (!res) return "None";
    let row = `${res.status_code} ${res.reason_phrase}`;
    if (res.body) row += `: ${res.body}`;
    return row;
  };

  return Object.entries(vulnerabilityMap)
    .map(
      ([name, data]) => `
    <div class="enumerated-container" id=${data.name.replace(/ /g, "-")}>
      <h3 class="enumerated-header">${name}</h3>
      <table>
        <thead>
          <tr>
            <th>Detected</th>
            <th>Request</th>
            <th>Response</th>
            <th style="width: 40%;">Description</th>
          </tr>
        </thead>
        <tbody>
        ${data.instances
          .map((inst) => {
            const { request, response, summary } = inst;
            return `
          <tr>
            <td>${formatTime(data.date)}</td>
            <td class="break-words">${
              request ? `${request.method} ${request.url}` : "None"
            }</td>
            <td class="break-words">
              ${responseCell(response)}
            </td>
            <td class="break-words">${escapeHtmlTags(summary) ?? "None"}</td>
          </tr>
        `;
          })
          .join("")}
        </tbody>
      </table>
    </div>
  `,
    )
    .join("");
}

/**
 * Generate HTML page from parsed data.
 * @param {string[]} filePaths - The list of JSON file paths
 * @returns {string}
 */
function generateHtmlPage(filePaths) {
  const data = filePaths.map((filePath) => readJSONFile(filePath));
  const parsedData = parseData(data);

  const templateMap = {
    endpoints: generateEndpointsHtml(parsedData.endpoints),
    kpis: generateKpiHtml(parsedData.kpis),
    reportDate: formatDate(),
    results: generateResultsHtml(parsedData.vulnerabilities),
    resultSections: generateExpandedResultsHtml(parsedData.vulnerabilities),
    scanners: generateScanMetadataHtml(parsedData.scans),
  };

  const htmlTemplate = readFileSync(
    resolve(__dirname, "template.html"),
    "utf8",
  );
  const htmlContent = htmlTemplate.replace(/({{\w+}})/g, (_match, p1) => {
    const key = p1.slice(2, -2);
    return templateMap[key];
  });
  return htmlContent;
}

/**
 * Generate HTML for severity counts.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @returns {string}
 */
function generateKpiHtml(kpis) {
  return Object.entries(kpis)
    .map(
      ([severity, count]) => `
    <div style="margin-top: 0.625rem;">
      <div class="metric-title">
          ${severity}
      </div>
      <div class="metric-value">
         ${count} 
      </div>
  </div>
`,
    )
    .join("");
}

/**
 * Select the most relevant identifier for a vulnerability.
 * @param {Vulnerability} vuln - The vulnerability to select an identifier for
 * @returns {string}
 */
function getVulnerabilityCommonName(vuln) {
  return vuln.identifiers.reduce((current, id) => {
    if (["browserker", "ApiSecurityCheck"].includes(id.type.toLowerCase())) {
      return id.name;
    } else if (!current) {
      return id.name;
    }
    return id.name;
  }, "");
}

/**
 * Generate HTML for vulnerability results.
 * @param {Vulnerability[]} vulnerabilities - The list of discovered vulnerabilities
 * @returns {string}
 */
function generateResultsHtml(vulnerabilities) {
  let discovered = new Set();
  return vulnerabilities
    .map((vuln) => ({
      ...vuln,
      name: getVulnerabilityCommonName(vuln),
    }))
    .filter((vuln) => {
      if (!discovered.has(vuln.name)) {
        discovered.add(vuln.name);
        return true;
      }
      return false;
    })
    .map(
      (vuln) => `
      <tr>
        <td>${vuln.severity}</td>
        <td style="width: 50%;">${vuln.description ?? "None"}</td>
        <td>
          <a class="link-styles" href="#${vuln.name.replace(/ /g, "-")}">${
        vuln.name
      }</a>
        </td>
    `,
    )
    .join("");
}

/**
 * Generate HTML for a scanner's metadata.
 * @param {ScanMetadata[]} scans - The metadata of the scan result data
 * @returns {string}
 */
function generateScanMetadataHtml(scans) {
  return scans
    .map(
      (scan) => `
    <tr>
      <td>${formatTime(scan.start_time)} - ${formatTime(scan.end_time)}</td>
      <td><a class="link-styles" href="${
        scan.url
      }" target="_blank" rel="noopener noreferrer">${scan.name}</a></td>
      <td>${scan.version}</td>
      <td>${scan.id}</td>
    </tr>
  `,
    )
    .join("");
}

/**
 * Parse data from JSON scan files.
 * @param {DastResultData[]} data - An array of scan result data
 * @returns {ParsedData}
 */
function parseData(data) {
  const severities = ["Low", "Medium", "High", "Critical", "Info", "Unknown"];
  /** @type {ParsedData} */
  const accumulator = {
    endpoints: [],
    kpis: severities.reduce((obj, sev) => ({ ...obj, [sev]: 0 }), {}),
    scans: [],
    vulnerabilities: [],
  };
  return data.reduce((sections, datum) => {
    return {
      ...sections,
      endpoints: sections.endpoints.concat(
        datum.scan.scanned_resources.map((resource) => ({
          url: resource.url,
          scannerId: datum.scan.scanner.id,
        })),
      ),
      kpis: updateKpis(sections.kpis, datum.vulnerabilities),
      scans: sections.scans.concat({
        ...datum.scan.scanner,
        start_time: datum.scan.start_time,
        end_time: datum.scan.end_time,
      }),
      vulnerabilities: sections.vulnerabilities.concat(datum.vulnerabilities),
    };
  }, accumulator);
}

/**
 * Read a JSON file.
 * @param {string} filePath - A JSON file to parse
 * @returns {DastResultData}
 */
function readJSONFile(filePath) {
  try {
    const jsonData = readFileSync(filePath, "utf8");
    return JSON.parse(jsonData);
  } catch (err) {
    console.error("Error reading JSON file.");
    throw err;
  }
}

/**
 * Generate an object enumerating the counts of each severity level discovered in the scan.
 * @param {{ [key: string]: number }} kpis - The vulnerability counts found by severity
 * @param {Vulnerability[]} vulns - The list of discovered vulnerabilities
 * @return {{ [key: string]: number }}
 */
function updateKpis(kpis, vulns) {
  return vulns.reduce((kpis, vuln) => {
    const severity = vuln.severity;
    kpis[severity] = kpis[severity] + 1 || 1;
    return kpis;
  }, kpis);
}

/*
## Main
*/

/**
 * Read filenames from command-line arguments
 * @param {string[]} args - The command-line arguments
 * @param {number} status - The exit status
 * @returns {void}
 */
const returnUsage = (args, status = 0) => {
  console.log(`
  Usage: ${basename(args[0])} ${basename(
    args[1],
  )} [-h|--help] [-o|--output <file>.html] <file>.json...`);
  exit(status);
};

try {
  const {
    values: { help, output: outFilePath },
    positionals: inFilePaths,
  } = parseArgs({
    options: {
      help: {
        type: "boolean",
        short: "h",
      },
      output: {
        type: "string",
        short: "o",
      },
    },
    allowPositionals: true,
  });


  if (help) returnUsage(process.argv);

  // Check if filenames are provided.
  if (inFilePaths.length === 0) {
    returnUsage(process.argv, 1);
  }

  const dataFilePaths = inFilePaths.map((filePath) => {
    if (isInsideDocker) {
      filePath = `/data/${filePath}`;
    }
    return filePath;
  });

  // Check if filenames exist.
  let allFilesExist = true;
  dataFilePaths.forEach((filePath) => {
    if (!existsSync(filePath)) {
      console.log(`File does not exist or is not accessible: '${filePath}'`);
      allFilesExist = false;
    }
  });
  if (!allFilesExist) exit();

  // Generate an HTML page from the provided JSON files.
  const htmlContent = generateHtmlPage(dataFilePaths);
  const outputFilePathTemp = outFilePath ?? "report.html";
  const outputReport = isInsideDocker ? `/output/${outputFilePathTemp}` : outputFilePathTemp;
  const filepath = resolve(__dirname, outputReport ?? "report.html");
  writeFileSync(filepath, htmlContent);
  console.log("");
  console.log(`Vulnerability report written to ${filepath}`);
} catch (err) {
  returnUsage(process.argv, 1);
}
